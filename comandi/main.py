'''
The core functionality of the program includes converting human instructions to command-line instructions, providing programming hints and examples, and analyzing file contents for understanding, debugging, and fixing. 
The program follows a loop that continuously prompts the user for input until the user decides to exit. Depending on the type of user input, the program will either 
execute a command, analyze a file, or provide hints and examples.
'''

import sys
import subprocess
import json
import os
from meta_ai_api import MetaAI
from rich.console import Console
from rich.prompt import Prompt
from rich.panel import Panel
from rich.align import Align
from rich.text import Text

# Initialize the rich console
console = Console()


'''
This function is responsible for loading the prompt template from a JSON file named prompt.json. Attempts to open and read the file => 
If successful, it extracts and returns the prompt_template key from the loaded JSON data. 
If the file is not found, contains invalid JSON, or is missing the prompt_template key, 
the function catches these exceptions and displays an appropriate error message to the user via the console, then exits the program.
'''
def load_prompt():
    try:
        with open('prompt.json', 'r') as file:
            data = json.load(file)
            return data['prompt_template']
    except FileNotFoundError:
        console.print("[bold red]Error:[/bold red] prompt.json file not found.")
        sys.exit(1)
    except json.JSONDecodeError:
        console.print("[bold red]Error:[/bold red] Invalid JSON in prompt.json file.")
        sys.exit(1)
    except KeyError:
        console.print("[bold red]Error:[/bold red] 'prompt_template' key not found in prompt.json.")
        sys.exit(1)




'''
prints an introductory message to the user when the program starts. 
creates a styled text block with the program's version, guidelines on how to use the CLI, and commands available to the user. The text is centered and wrapped in a Rich Panel, which is then printed to the console.
'''
def print_introduction():
    intro_text = Text(justify="center")
    intro_text.append("COMANDI v0.0.2\n\n", style="bold spring_green2")
    
    intro_text.append("üìã ")
    intro_text.append("Guidelines\n", style="bold white")
    
    intro_text.append("Type your request for command-line equivalents\n", style="white")
    intro_text.append("Ask programming questions for hints and examples\n", style="white")
    intro_text.append("Use 'understand', 'debug', or 'fix' followed by a file path for file analysis\n", style="white")
    intro_text.append("Type 'quit' or 'exit' to end the session\n\n", style="white")

    intro_panel = Panel(
        Align.center(intro_text, vertical="middle")
    )

    console.print(intro_panel)



'''
Execute shell commands provided by the user or generated by the AI. 
It runs the command in a subprocess and captures its output or error messages. 
The function then returns the command output if it is successful; 
otherwise, it returns an error message. 
This function allows the program to interact with the system's shell environment and execute various commands on the user's behalf.
'''
def execute_command(command):
    """Execute shell commands."""
    try:
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output, error = process.communicate()
        return output.strip() if process.returncode == 0 else f"Error: {error.strip()}"
    except Exception as e:
        return f"An error occurred while executing the command: {str(e)}"


'''
constructs a full prompt by combining the template with the user's input, then sends this prompt to the AI. The function receives and parses the AI's response, extracting useful information like commands, hints, and examples.
'''
def get_ai_response(user_input, prompt_template):
    """Get AI response for user input."""
    meta = MetaAI()
    full_prompt = f"{prompt_template}\n\nUser input: {user_input}\n\nResponse:"
    response = meta.prompt(message=full_prompt)
    return parse_ai_response(response['message'].strip())


# the following funcstions are self explanatory im not documenting this now
def parse_ai_response(response):
    """Parse AI response."""
    lines = response.split('\n')
    result = {}
    example_lines = []
    in_example = False

    for line in lines:
        if line.startswith('COMMAND:'):
            result['type'] = 'command'
            result['command'] = line.split('COMMAND:')[1].strip()
        elif line.startswith('DESCRIPTION:'):
            result['description'] = line.split('DESCRIPTION:')[1].strip()
        elif line.startswith('HINT:'):
            result['type'] = 'hint'
            result['hint'] = line.split('HINT:')[1].strip()
        elif line.startswith('EXAMPLE:'):
            in_example = True
            continue
        elif in_example:
            example_lines.append(line)
        elif line.startswith(('SUMMARY:', 'IMPROVEMENTS:', 'DEBUGGING TIPS:', 'CODE FIXES:')):
            section = line.split(':')[0].strip()
            result[section] = []
        elif any(key in result for key in ['SUMMARY', 'IMPROVEMENTS', 'DEBUGGING TIPS', 'CODE FIXES']):
            for key in ['SUMMARY', 'IMPROVEMENTS', 'DEBUGGING TIPS', 'CODE FIXES']:
                if key in result:
                    result[key].append(line.strip())
                    break

    if example_lines:
        result['example'] = '\n'.join(example_lines).strip()

    return result

def read_file_contents(file_path):
    """Read and return the contents of a file."""
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return f"Error: File '{file_path}' not found."
    except Exception as e:
        return f"Error reading file: {str(e)}"


def analyze_file(file_path, analysis_type):
    """Analyze file contents based on the analysis type."""
    content = read_file_contents(file_path)
    if content.startswith("Error:"):
        return content

    prompt_template = load_prompt()
    
    if analysis_type == "understand":
        prompt = f"{prompt_template}\nAnalyze and summarize the following file contents:\n\n{content}\n\nProvide a brief summary and improvement tips."
    elif analysis_type == "debug":
        prompt = f"{prompt_template}\nAnalyze the following code for potential bugs and provide debugging tips:\n\n{content}"
    elif analysis_type == "fix":
        prompt = f"{prompt_template}\nAnalyze the following code, identify errors, and suggest fixes:\n\n{content}"
    else:
        return "Invalid analysis type."

    return get_ai_response(prompt, prompt_template)



def display_file_analysis(analysis_result):
    """Display file analysis results using Rich panels."""
    for section, content in analysis_result.items():
        if isinstance(content, list) and content:
            panel = Panel(
                Text('\n'.join(content), style="white"),
                title=f"üìä {section}:",
                border_style="bold spring_green1",
                style="white"
            )
            console.print(panel)


'''
This function handles file-related commands by determining the type of analysis requested (understand, debug, or fix) and then calling analyze_file() to perform the analysis. If the file does not exist, it prints an error message. If the analysis is successful, it uses display_file_analysis() to show the results to the user. This function serves as a central hub for managing file-related tasks within the program.
'''
def handle_file_command(command, file_path):
    """Handle file-related commands."""
    if not os.path.exists(file_path):
        console.print(f"[bold red]Error:[/bold red] File '{file_path}' not found.")
        return

    analysis_type = command.split()[0]
    analysis_result = analyze_file(file_path, analysis_type)
    
    if isinstance(analysis_result, str) and analysis_result.startswith("Error:"):
        console.print(f"[bold red]{analysis_result}[/bold red]")
    else:
        display_file_analysis(analysis_result)



'''
The main function is the entry point of the program and manages the overall flow of the CLI. It starts by loading the prompt template and printing the introduction. The function then enters a loop where it continuously prompts the user for input.
Depending on the input, it either handles file-related commands, sends the input to the AI for processing, or exits the program. 
The main function ensures that the program operates as an interactive tool, responding to user input in real-time and handling various tasks as specified by the user.
'''
def main():
    """Main function to run the CLI interface."""
    prompt_template = load_prompt()

    print_introduction()

    try:
        # the best part of the whole code
        # this analysis the response and creates the panel accordingly 
        # very easy to add more functionality this way, might be better methods of doing so, but im not going to think much
        while True:
            user_input = Prompt.ask(Text("::", style="green1"))

            if user_input.lower() in ['quit', 'exit']:
                console.print(Text("üöÄ Goodbye! üëã See you soon!", style="bold red1"))
                break

            if user_input.startswith(('understand ', 'debug ', 'fix ')):
                command, *file_path = user_input.split(maxsplit=1)
                if file_path:
                    handle_file_command(command, file_path[0])
                else:
                    console.print("[bold red]Error:[/bold red] Please provide a file path.")
            else:
                try:
                    ai_response = get_ai_response(user_input, prompt_template)

                    if ai_response['type'] == 'hint':
                        hint_panel = Panel(
                            Text(ai_response['hint'], style="white"),
                            title="üí° Programming Hint:",
                            border_style="bold spring_green1",
                            style="white"
                        )
                        console.print(hint_panel)
                        
                        if 'example' in ai_response:
                            example_panel = Panel(
                                Text(ai_response['example'], style="white"),
                                title="üìö Example:",
                                border_style="bold deep_pink3",
                                style="white"
                            )
                            console.print(example_panel)

                    elif ai_response['type'] == 'command':
                        if ai_response.get('command') == 'UNABLE_TO_PROCESS':
                            console.print(Text(ai_response.get('description', 'Unable to process the request.'), style="yellow"))
                        else:
                            command_panel = Panel(
                                Text(ai_response.get('command', 'No command provided.'), style="white"),
                                title="üõ†Ô∏è Command:",
                                border_style="bold deep_pink3",
                                style="white"
                            )
                            console.print(command_panel)
                            
                            description_panel = Panel(
                                Text(ai_response.get('description', 'No description provided.'), style="white"),
                                title="üìÑ Description:",
                                border_style="spring_green1",
                                style="white"
                            )
                            console.print(description_panel)

                            execute_choice = Prompt.ask(Text(" Execute this command? (y/n): ", style="spring_green1")).lower()

                            if execute_choice == 'y':
                                command_output = execute_command(ai_response['command'])
                                output_panel = Panel(
                                    Text(command_output, style="white"),
                                    title="üîç Command Output:",
                                    border_style="spring_green1",
                                    style="white"
                                )
                                console.print(output_panel)

                    console.print()  # Add a blank line for readability

                except Exception as e:
                    console.print(Panel(Text(f"‚ùå An error occurred: {str(e)}", style="bold red"), border_style="bold red"))

    except KeyboardInterrupt:
        console.print(Panel(Text("üîö Session ended by user.", style="bold cyan"), border_style="bold cyan"))
        sys.exit(0)


if __name__ == "__main__":
    main()